<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Response Rate by Client</title>

  <!-- Chart.js UMD (auto-registers all components) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      /* Light theme */
      --bg:#f6f8fc;           /* very light */
      --panel:#ffffff;        /* white card */
      --fg:#111827;           /* slate-900 */
      --fg-muted:#4b5563;     /* slate-600 */
      --grid:rgba(0,0,0,0.06);
    }
    body { font-family: Arial, sans-serif; margin: 32px; background: var(--bg); color: var(--fg); }
    h2 { text-align: center; font-size: 28px; margin-bottom: 16px; }
    .controls{
      display:flex;
      gap:12px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:8px;
    }
    input[type="file"], select, label { font-size: 15px; }
    select { padding:8px 10px; }
    label { display:flex; gap:8px; align-items:center; }
    .status {
      text-align:center;
      font-size: 18px;       /* bigger: treat as title */
      font-weight: 600;      /* bold */
      color: var(--fg-muted);
      margin: 6px 0 14px;
    }
    .chart-container {
      position: relative;
      width: 95%;
      max-width: 1400px;
      height: 700px;
      margin: 0 auto;
      background: var(--panel);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 24px rgba(16,24,40,0.08);
      border: 1px solid rgba(0,0,0,0.06);
    }
    canvas { width: 100% !important; height: 100% !important; cursor: crosshair; }
  </style>
</head>
<body>
  <h2>Response Rate by Client</h2>

  <div class="controls">
    <input type="file" id="csvFile" accept=".csv" />

    <!-- Module / SubModule filters -->
    <select id="moduleSelect">
      <option value="">— All Modules —</option>
    </select>
    <select id="subModuleSelect" disabled>
      <option value="">— All SubModules —</option>
    </select>

    <select id="clientSelect">
      <option value="">— Highlight a Client —</option>
    </select>
    <label><input type="checkbox" id="deltaToggle"> Show Submission Delta</label>
  </div>

  <!-- This acts as the dynamic title, now larger -->
  <div class="status" id="status">
    Click a line to spotlight it. Others stay visible but lighter. Legend hidden to avoid clutter.
  </div>

  <div class="chart-container">
    <canvas id="responseChart"></canvas>
  </div>

  <script>
    const fileInput      = document.getElementById('csvFile');
    const clientSelect   = document.getElementById('clientSelect');
    const deltaToggle    = document.getElementById('deltaToggle');
    const moduleSelect   = document.getElementById('moduleSelect');
    const subModuleSelect= document.getElementById('subModuleSelect');
    const statusEl       = document.getElementById('status');
    const ctx            = document.getElementById('responseChart').getContext('2d');

    let chart;
    let csvData = [];
    let allClients = [];
    let labelsSorted = [];
    let activeClient = null; // client highlighted via click or dropdown

    // ---- Helpers ----
    const trim = v => (typeof v === 'string' ? v.trim() : v);
    const toNum = v => {
      if (v === null || v === undefined) return null;
      const s = String(v).trim().replace(/%/g,'').replace(/,/g,'');
      if (s === '') return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };

    // Colors (12 distinct). We'll keep base colors to re-apply with alpha for dimming
    const baseColors = ['#2563eb','#f97316','#16a34a','#a855f7','#dc2626','#0891b2','#7c3aed','#059669','#ea580c','#0ea5e9','#ca8a04','#d946ef'];

    function hexToRgba(hex, alpha=1) {
      if (!hex) return `rgba(0,0,0,${alpha})`;
      if (hex.startsWith('rgba')) {
        return hex.replace(/rgba\(([^)]+)\)/, (m, inner)=>
          `rgba(${inner.split(',').slice(0,3).join(',')},${alpha})`
        );
      }
      if (!hex.startsWith('#')) return hex; // assume already a css color
      const h = hex.replace('#','');
      const bigint = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
      const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // Header aliases for robustness
    const Fields = {
      date:   ['SnapshotDate','Snapshot Date','Date','snapshotdate'],
      client: ['ClientDBName','Client DB Name','Client','client','ClientName'],
      rate:   ['SubmissionRate','Submission Rate','ResponseRate','Response Rate','Rate'],
      // include both singular and plural spellings
      delta:  ['SubmissionsDelta','SubmissionDelta','Submission Delta','Delta','DeltaSubmission','Change'],
      module: ['ModuleName','Module Name','Module','module'],
      subModule: ['SubModuleName','SubModule Name','SubModule','Sub Module','submodule']
    };
    function pick(row, keys){ for(const k of keys){ if (k in row) return row[k]; } return undefined; }

    // Parse date -> millis (supports YYYY-MM-DD, M/D/YYYY, ISO-ish fallbacks)
    function parseDateMillis(s) {
      if (!s) return null;
      const str = String(s).trim(); let y,m,d;
      if (/^[0-9]{4}-[0-9]{1,2}-[0-9]{1,2}$/.test(str)) {
        [y,m,d]=str.split('-').map(n=>parseInt(n,10));
      } else if (/^[0-9]{1,2}\/[0-9]{1,2}\/[0-9]{4}$/.test(str)) {
        [m,d,y]=str.split('/').map(n=>parseInt(n,10));
      } else {
        const t = Date.parse(str);
        return Number.isNaN(t)?null:t;
      }
      if (!y||!m||!d) return null;
      return new Date(y, m-1, d).getTime();
    }

    // Get rows filtered by Module/SubModule selection
    function getFilteredRows() {
      const selectedModule    = moduleSelect.value || null;
      const selectedSubModule = subModuleSelect.value || null;
      if (!selectedModule && !selectedSubModule) return csvData;

      return csvData.filter(r => {
        const mVal = trim(pick(r, Fields.module));
        const sVal = trim(pick(r, Fields.subModule));
        if (selectedModule && mVal !== selectedModule) return false;
        if (selectedSubModule && sVal !== selectedSubModule) return false;
        return true;
      });
    }

    function computeLabels(data) {
      const uniq = new Set();
      data.forEach(r => {
        const d = trim(pick(r, Fields.date));
        if (d) uniq.add(d);
      });
      labelsSorted = [...uniq]
        .filter(ds => parseDateMillis(ds) !== null)
        .sort((a,b) => parseDateMillis(a) - parseDateMillis(b));
    }

    function populateClients(data) {
      allClients = [...new Set(
        data.map(r => trim(pick(r, Fields.client))).filter(Boolean)
      )].sort();

      const prevActive = activeClient;

      clientSelect.innerHTML = '<option value="">— Highlight a Client —</option>';
      allClients.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        clientSelect.appendChild(opt);
      });

      // Preserve selection if possible
      if (prevActive && allClients.includes(prevActive)) {
        activeClient = prevActive;
        clientSelect.value = prevActive;
      } else if (!allClients.includes(activeClient)) {
        activeClient = null;
        clientSelect.value = '';
      }
    }

    function populateModules(data) {
      const modules = [...new Set(
        data.map(r => trim(pick(r, Fields.module))).filter(Boolean)
      )].sort();

      moduleSelect.innerHTML = '<option value="">— All Modules —</option>';
      modules.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        moduleSelect.appendChild(opt);
      });

      // reset SubModule dropdown
      subModuleSelect.innerHTML = '<option value="">— All SubModules —</option>';
      subModuleSelect.disabled = true;
    }

    function populateSubModules(data, moduleValue) {
      subModuleSelect.innerHTML = '<option value="">— All SubModules —</option>';
      if (!moduleValue) {
        subModuleSelect.disabled = true;
        return;
      }
      const subs = [...new Set(
        data
          .filter(r => trim(pick(r, Fields.module)) === moduleValue)
          .map(r => trim(pick(r, Fields.subModule)))
          .filter(Boolean)
      )].sort();

      subs.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s;
        subModuleSelect.appendChild(opt);
      });

      subModuleSelect.disabled = subs.length === 0;
    }

    // Build maps: client -> { dateStr -> value }
    function buildMaps(data) {
      const rateMap  = {};
      const deltaMap = {};
      data.forEach(row => {
        const client = trim(pick(row, Fields.client));
        const date   = trim(pick(row, Fields.date));
        if (!client || !date) return;
        const rate  = toNum(pick(row, Fields.rate));
        const delta = toNum(pick(row, Fields.delta));
        (rateMap[client]  ||= {})[date]  = rate;
        (deltaMap[client] ||= {})[date]  = delta;
      });
      return { rateMap, deltaMap };
    }

    function buildLineDatasets(rateMap) {
      return allClients.map((client,i) => {
        const map = rateMap[client] || {};
        const series = labelsSorted.map(lbl => map[lbl] ?? null);
        const col = baseColors[i % baseColors.length];
        return {
          label: client + ' - Response Rate',
          data: series,
          type: 'line',
          borderColor: col,
          backgroundColor: col,
          tension: 0.25,
          pointRadius: 2,
          borderWidth: 2,
          spanGaps: true,
          yAxisID: 'y',
          order: 1,
          baseColor: col // custom field for our highlight logic
        };
      });
    }

    function buildDeltaDataset(deltaMap, selectedClient) {
      let dataAligned = [];
      if (selectedClient) {
        const map = deltaMap[selectedClient] || {};
        dataAligned = labelsSorted.map(lbl => map[lbl] ?? null);
      } else {
        dataAligned = labelsSorted.map(lbl => {
          let sum = 0, cnt = 0;
          allClients.forEach(c => {
            const v = (deltaMap[c] || {})[lbl];
            if (v !== null && v !== undefined) {
              sum += v;
              cnt++;
            }
          });
          return cnt ? sum / cnt : null;
        });
      }
      return {
        label: 'Submission Delta',
        data: dataAligned,
        type: 'bar',
        backgroundColor: 'rgba(37, 99, 235, 0.25)',
        borderColor: 'rgba(37, 99, 235, 0.8)',
        borderWidth: 1,
        yAxisID: 'y2',
        order: 0,
        categoryPercentage: 0.9,
        barPercentage: 0.9,
        maxBarThickness: 28,
        borderRadius: 3,
      };
    }

    function getSelectedClient(){ return activeClient || (clientSelect.value || null); }

    function render(showDelta=false) {
      const rows = getFilteredRows();

      if (!rows.length) {
        if (chart) chart.destroy();
        statusEl.textContent = 'No data for this Module/SubModule selection.';
        return;
      }

      computeLabels(rows);
      populateClients(rows);
      const { rateMap, deltaMap } = buildMaps(rows);
      const datasets = buildLineDatasets(rateMap);
      if (showDelta) datasets.push(buildDeltaDataset(deltaMap, getSelectedClient()));

      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels: labelsSorted, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: { enabled: true }
          },
          scales: {
            x: {
              title: { display: true, text: 'Date' },
              ticks: { color: '#111827' },
              grid: { color: 'var(--grid)' }
            },
            y: {
              title: { display: true, text: 'Response Rate (%)' },
              beginAtZero: true,
              position: 'left',
              ticks: { color: '#111827' },
              grid: { color: 'var(--grid)' }
            },
            y2: {
              title: { display: showDelta, text: 'Submission Delta' },
              beginAtZero: true,
              position: 'right',
              grid: { drawOnChartArea: false, color: 'var(--grid)' },
              ticks: { color: '#111827' },
              display: showDelta
            }
          },
          // Click-to-highlight a line dataset
          onClick: (evt) => {
            const elems = chart.getElementsAtEventForMode(
              evt,
              'nearest',
              { intersect: false },
              true
            );
            if (!elems || !elems.length) return;
            const { datasetIndex } = elems[0];
            const ds = chart.data.datasets[datasetIndex];
            if (!ds || ds.type !== 'line') return; // only lines are highlightable

            const client = ds.label.replace(' - Response Rate','');
            // Toggle highlight if same line clicked again
            activeClient = (activeClient === client) ? null : client;
            clientSelect.value = activeClient || '';
            applyHighlight();

            // Rebuild delta bar so it follows selected client when enabled
            if (deltaToggle.checked) {
              const rowsNow = getFilteredRows();
              const { deltaMap } = buildMaps(rowsNow);
              const bar = buildDeltaDataset(deltaMap, getSelectedClient());
              // remove any existing bar dataset
              chart.data.datasets = chart.data.datasets.filter(d => d.type !== 'bar');
              chart.data.datasets.push(bar);
              chart.update();
            }
            updateStatus();
          }
        }
      });

      applyHighlight();
      updateStatus();
    }

    function applyHighlight() {
      if (!chart) return;
      const selected = getSelectedClient();
      chart.data.datasets.forEach(ds => {
        if (ds.type !== 'line') return;
        const base = ds.baseColor || ds.borderColor;
        if (!selected) {
          ds.borderColor = hexToRgba(base, 1);
          ds.pointRadius = 2;
          ds.borderWidth = 2;
          ds.order = 1;
          return;
        }
        if (ds.label === (selected + ' - Response Rate')) {
          ds.borderColor = hexToRgba(base, 1);
          ds.pointRadius = 3;
          ds.borderWidth = 5;
          ds.order = 10; // draw on top
        } else {
          ds.borderColor = hexToRgba(base, 0.25);
          ds.pointRadius = 1;
          ds.borderWidth = 2;
          ds.order = 1;
        }
      });
      chart.update();
    }

    function updateStatus(){
      const sel = getSelectedClient();
      const m = moduleSelect.value || 'All Modules';
      const s = (!subModuleSelect.disabled && subModuleSelect.value) ? subModuleSelect.value : 'All SubModules';
      const deltaMsg = deltaToggle.checked
        ? (sel ? `Delta bars: ${sel}` : 'Delta bars: average across clients')
        : 'Delta bars hidden';
      statusEl.textContent =
        `Module: ${m} · SubModule: ${s} · ` +
        `${sel ? `Highlighted: ${sel}` : 'No client highlighted'} · ${deltaMsg}.`;
    }

    const DEFAULT_CSV_URL = './many_modules_part_level.csv';

    function handleParsedResults(results) {
      csvData = (results.data || []).filter(r => r && pick(r, Fields.date) && pick(r, Fields.client));
      if (!csvData.length) {
        alert('No valid rows found. Check your headers.');
        return;
      }
      activeClient = null; // reset highlight on new file
      clientSelect.value = '';
      populateModules(csvData);
      render(deltaToggle.checked);
    }

    function parseCsvText(csvText) {
      Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true,
        transformHeader: h => String(h).trim(),
        transform: v => (typeof v === 'string' ? v.trim() : v),
        complete: handleParsedResults,
        error: (err) => {
          console.error('CSV parse error:', err);
          alert('Could not parse CSV. See console for details.');
        }
      });
    }

    // ---- Events ----
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        transformHeader: h => String(h).trim(),
        transform: v => (typeof v === 'string' ? v.trim() : v),
        complete: handleParsedResults,
        error: (err) => {
          console.error('CSV parse error:', err);
          alert('Could not parse CSV. See console for details.');
        }
      });
    });

    async function loadDefaultCsv() {
      try {
        const response = await fetch(DEFAULT_CSV_URL, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Fetch failed: ${response.status}`);
        }
        const csvText = await response.text();
        parseCsvText(csvText);
      } catch (err) {
        console.error('Auto-load CSV failed:', err);
      }
    }

    clientSelect.addEventListener('change', () => {
      activeClient = clientSelect.value || null;
      applyHighlight();
      updateStatus();
      if (deltaToggle.checked) render(true);
    });

    deltaToggle.addEventListener('change', () => {
      render(deltaToggle.checked);
    });

    moduleSelect.addEventListener('change', () => {
      // Reset client highlight when module changes
      activeClient = null;
      clientSelect.value = '';
      // Update submodules for this module
      const mVal = moduleSelect.value || null;
      populateSubModules(csvData, mVal);
      // Reset any submodule selection
      if (!mVal) {
        subModuleSelect.value = '';
      }
      render(deltaToggle.checked);
    });

    subModuleSelect.addEventListener('change', () => {
      // Reset client highlight when submodule changes
      activeClient = null;
      clientSelect.value = '';
      render(deltaToggle.checked);
    });

    window.addEventListener('DOMContentLoaded', () => {
      loadDefaultCsv();
    });
  </script>
</body>
</html>
